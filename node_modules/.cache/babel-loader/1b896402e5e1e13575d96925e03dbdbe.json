{"ast":null,"code":"import features from \"./features\";\nimport Debouncer from \"./Debouncer\";\n/**\n * Check if object is part of the DOM\n * @constructor\n * @param {Object} obj element to check\n */\n\nfunction isDOMElement(obj) {\n  return obj && typeof window !== \"undefined\" && (obj === window || obj.nodeType);\n}\n/**\n * Helper function for extending objects\n */\n\n\nfunction extend(object\n/*, objectN ... */\n) {\n  if (arguments.length <= 0) {\n    throw new Error(\"Missing arguments in extend function\");\n  }\n\n  var result = object || {},\n      key,\n      i;\n\n  for (i = 1; i < arguments.length; i++) {\n    var replacement = arguments[i] || {};\n\n    for (key in replacement) {\n      // Recurse into object except if the object is a DOM element\n      if (typeof result[key] === \"object\" && !isDOMElement(result[key])) {\n        result[key] = extend(result[key], replacement[key]);\n      } else {\n        result[key] = result[key] || replacement[key];\n      }\n    }\n  }\n\n  return result;\n}\n/**\n * Used to detect browser support for adding an event listener with options\n * Credit: https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\n */\n\n\nvar supportsCaptureOption = false;\n\ntry {\n  var opts = Object.defineProperty({}, \"capture\", {\n    get: function () {\n      return supportsCaptureOption = true;\n    }\n  });\n  window.addEventListener(\"test\", null, opts);\n  window.removeEventListener(\"test\", null, opts);\n} catch (e) {}\n/* eslint-ignore-line */\n\n/**\n * Helper to add an event listener with an options object in supported browsers\n */\n\n\nfunction addEventListenerWithOptions(target, type, handler, options) {\n  var optionsOrCapture = options;\n\n  if (!supportsCaptureOption) {\n    optionsOrCapture = options.capture;\n  }\n\n  target.addEventListener(type, handler, optionsOrCapture);\n}\n/**\n * Helper to remove an event listener with an options object in supported browsers\n */\n\n\nfunction removeEventListenerWithOptions(target, type, handler, options) {\n  var optionsOrCapture = options;\n\n  if (!supportsCaptureOption) {\n    optionsOrCapture = options.capture;\n  }\n\n  target.removeEventListener(type, handler, optionsOrCapture);\n}\n/**\n * Helper function for normalizing tolerance option to object format\n */\n\n\nfunction normalizeTolerance(t) {\n  return t === Object(t) ? t : {\n    down: t,\n    up: t\n  };\n}\n/**\n * UI enhancement for fixed headers.\n * Hides header when scrolling down\n * Shows header when scrolling up\n * @constructor\n * @param {DOMElement} elem the header element\n * @param {Object} options options for the widget\n */\n\n\nfunction Headroom(elem, options) {\n  options = extend(options, Headroom.options);\n  this.lastKnownScrollY = 0;\n  this.elem = elem;\n  this.tolerance = normalizeTolerance(options.tolerance);\n  this.classes = options.classes;\n  this.offset = options.offset;\n  this.scroller = options.scroller;\n  this.initialised = false;\n  this.onPin = options.onPin;\n  this.onUnpin = options.onUnpin;\n  this.onTop = options.onTop;\n  this.onNotTop = options.onNotTop;\n  this.onBottom = options.onBottom;\n  this.onNotBottom = options.onNotBottom;\n  this.frozen = false;\n}\n\nHeadroom.prototype = {\n  constructor: Headroom,\n\n  /**\n   * Initialises the widget\n   */\n  init: function () {\n    if (!Headroom.cutsTheMustard) {\n      return;\n    }\n\n    this.debouncer = new Debouncer(this.update.bind(this));\n    this.elem.classList.add(this.classes.initial); // defer event registration to handle browser\n    // potentially restoring previous scroll position\n\n    setTimeout(this.attachEvent.bind(this), 100);\n    return this;\n  },\n\n  /**\n   * Unattaches events and removes any classes that were added\n   */\n  destroy: function () {\n    var classes = this.classes;\n    this.initialised = false;\n\n    for (var key in classes) {\n      if (Object.prototype.hasOwnProperty.call(classes, key)) {\n        this.elem.classList.remove(classes[key]);\n      }\n    }\n\n    removeEventListenerWithOptions(this.scroller, \"scroll\", this.debouncer, {\n      capture: false,\n      passive: true\n    });\n  },\n\n  /**\n   * Attaches the scroll event\n   * @private\n   */\n  attachEvent: function () {\n    if (!this.initialised) {\n      this.lastKnownScrollY = this.getScrollY();\n      this.initialised = true;\n      addEventListenerWithOptions(this.scroller, \"scroll\", this.debouncer, {\n        capture: false,\n        passive: true\n      });\n      this.debouncer.handleEvent();\n    }\n  },\n\n  /**\n   * Unpins the header if it's currently pinned\n   */\n  unpin: function () {\n    var classList = this.elem.classList,\n        classes = this.classes;\n\n    if (classList.contains(classes.pinned) || !classList.contains(classes.unpinned)) {\n      classList.add(classes.unpinned);\n      classList.remove(classes.pinned);\n\n      if (this.onUnpin) {\n        this.onUnpin.call(this);\n      }\n    }\n  },\n\n  /**\n   * Pins the header if it's currently unpinned\n   */\n  pin: function () {\n    var classList = this.elem.classList,\n        classes = this.classes;\n\n    if (classList.contains(classes.unpinned)) {\n      classList.remove(classes.unpinned);\n      classList.add(classes.pinned);\n\n      if (this.onPin) {\n        this.onPin.call(this);\n      }\n    }\n  },\n\n  /**\n   * Handles the top states\n   */\n  top: function () {\n    var classList = this.elem.classList,\n        classes = this.classes;\n\n    if (!classList.contains(classes.top)) {\n      classList.add(classes.top);\n      classList.remove(classes.notTop);\n\n      if (this.onTop) {\n        this.onTop.call(this);\n      }\n    }\n  },\n\n  /**\n   * Handles the not top state\n   */\n  notTop: function () {\n    var classList = this.elem.classList,\n        classes = this.classes;\n\n    if (!classList.contains(classes.notTop)) {\n      classList.add(classes.notTop);\n      classList.remove(classes.top);\n\n      if (this.onNotTop) {\n        this.onNotTop.call(this);\n      }\n    }\n  },\n  bottom: function () {\n    var classList = this.elem.classList,\n        classes = this.classes;\n\n    if (!classList.contains(classes.bottom)) {\n      classList.add(classes.bottom);\n      classList.remove(classes.notBottom);\n\n      if (this.onBottom) {\n        this.onBottom.call(this);\n      }\n    }\n  },\n\n  /**\n   * Handles the not top state\n   */\n  notBottom: function () {\n    var classList = this.elem.classList,\n        classes = this.classes;\n\n    if (!classList.contains(classes.notBottom)) {\n      classList.add(classes.notBottom);\n      classList.remove(classes.bottom);\n\n      if (this.onNotBottom) {\n        this.onNotBottom.call(this);\n      }\n    }\n  },\n\n  /**\n   * Gets the Y scroll position\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollY\n   * @return {Number} pixels the page has scrolled along the Y-axis\n   */\n  getScrollY: function () {\n    if (this.scroller.pageYOffset !== undefined) {\n      return this.scroller.pageYOffset;\n    }\n\n    if (this.scroller.scrollTop !== undefined) {\n      return this.scroller.scrollTop;\n    }\n\n    return (document.documentElement || document.body.parentNode || document.body).scrollTop;\n  },\n\n  /**\n   * Gets the height of the viewport\n   * @see http://andylangton.co.uk/blog/development/get-viewport-size-width-and-height-javascript\n   * @return {int} the height of the viewport in pixels\n   */\n  getViewportHeight: function () {\n    return window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n  },\n\n  /**\n   * Gets the physical height of the DOM element\n   * @param  {Object}  elm the element to calculate the physical height of which\n   * @return {int}     the physical height of the element in pixels\n   */\n  getElementPhysicalHeight: function (elm) {\n    return Math.max(elm.offsetHeight, elm.clientHeight);\n  },\n\n  /**\n   * Gets the physical height of the scroller element\n   * @return {int} the physical height of the scroller element in pixels\n   */\n  getScrollerPhysicalHeight: function () {\n    return this.scroller === window || this.scroller === document.body ? this.getViewportHeight() : this.getElementPhysicalHeight(this.scroller);\n  },\n\n  /**\n   * Gets the height of the document\n   * @see http://james.padolsey.com/javascript/get-document-height-cross-browser/\n   * @return {int} the height of the document in pixels\n   */\n  getDocumentHeight: function () {\n    var body = document.body,\n        documentElement = document.documentElement;\n    return Math.max(body.scrollHeight, documentElement.scrollHeight, body.offsetHeight, documentElement.offsetHeight, body.clientHeight, documentElement.clientHeight);\n  },\n\n  /**\n   * Gets the height of the DOM element\n   * @param  {Object}  elm the element to calculate the height of which\n   * @return {int}     the height of the element in pixels\n   */\n  getElementHeight: function (elm) {\n    return Math.max(elm.scrollHeight, elm.offsetHeight, elm.clientHeight);\n  },\n\n  /**\n   * Gets the height of the scroller element\n   * @return {int} the height of the scroller element in pixels\n   */\n  getScrollerHeight: function () {\n    return this.scroller === window || this.scroller === document.body ? this.getDocumentHeight() : this.getElementHeight(this.scroller);\n  },\n\n  /**\n   * determines if the scroll position is outside of document boundaries\n   * @param  {int}  currentScrollY the current y scroll position\n   * @return {bool} true if out of bounds, false otherwise\n   */\n  isOutOfBounds: function (currentScrollY) {\n    var pastTop = currentScrollY < 0,\n        pastBottom = currentScrollY + this.getScrollerPhysicalHeight() > this.getScrollerHeight();\n    return pastTop || pastBottom;\n  },\n\n  /**\n   * determines if the tolerance has been exceeded\n   * @param  {int} currentScrollY the current scroll y position\n   * @return {bool} true if tolerance exceeded, false otherwise\n   */\n  toleranceExceeded: function (currentScrollY, direction) {\n    return Math.abs(currentScrollY - this.lastKnownScrollY) >= this.tolerance[direction];\n  },\n\n  /**\n   * determine if it is appropriate to unpin\n   * @param  {int} currentScrollY the current y scroll position\n   * @param  {bool} toleranceExceeded has the tolerance been exceeded?\n   * @return {bool} true if should unpin, false otherwise\n   */\n  shouldUnpin: function (currentScrollY, toleranceExceeded) {\n    var scrollingDown = currentScrollY > this.lastKnownScrollY,\n        pastOffset = currentScrollY >= this.offset;\n    return scrollingDown && pastOffset && toleranceExceeded;\n  },\n\n  /**\n   * determine if it is appropriate to pin\n   * @param  {int} currentScrollY the current y scroll position\n   * @param  {bool} toleranceExceeded has the tolerance been exceeded?\n   * @return {bool} true if should pin, false otherwise\n   */\n  shouldPin: function (currentScrollY, toleranceExceeded) {\n    var scrollingUp = currentScrollY < this.lastKnownScrollY,\n        pastOffset = currentScrollY <= this.offset;\n    return scrollingUp && toleranceExceeded || pastOffset;\n  },\n\n  /**\n   * Handles updating the state of the widget\n   */\n  update: function () {\n    var currentScrollY = this.getScrollY(),\n        scrollDirection = currentScrollY > this.lastKnownScrollY ? \"down\" : \"up\",\n        toleranceExceeded = this.toleranceExceeded(currentScrollY, scrollDirection);\n\n    if (this.isOutOfBounds(currentScrollY)) {\n      // Ignore bouncy scrolling in OSX\n      return;\n    }\n\n    if (this.frozen === true) {\n      this.lastKnownScrollY = currentScrollY;\n      return;\n    }\n\n    if (currentScrollY <= this.offset) {\n      this.top();\n    } else {\n      this.notTop();\n    }\n\n    if (currentScrollY + this.getViewportHeight() >= this.getScrollerHeight()) {\n      this.bottom();\n    } else {\n      this.notBottom();\n    }\n\n    if (this.shouldUnpin(currentScrollY, toleranceExceeded)) {\n      this.unpin();\n    } else if (this.shouldPin(currentScrollY, toleranceExceeded)) {\n      this.pin();\n    }\n\n    this.lastKnownScrollY = currentScrollY;\n  },\n\n  /**\n   * Freezes the current state of the widget\n   */\n  freeze: function () {\n    this.frozen = true;\n    this.elem.classList.add(this.classes.frozen);\n  },\n\n  /**\n   * Re-enables the default behaviour of the widget\n   */\n  unfreeze: function () {\n    this.frozen = false;\n    this.elem.classList.remove(this.classes.frozen);\n  }\n};\n/**\n * Default options\n * @type {Object}\n */\n\nHeadroom.options = {\n  tolerance: {\n    up: 0,\n    down: 0\n  },\n  offset: 0,\n  scroller: window,\n  classes: {\n    frozen: \"headroom--frozen\",\n    pinned: \"headroom--pinned\",\n    unpinned: \"headroom--unpinned\",\n    top: \"headroom--top\",\n    notTop: \"headroom--not-top\",\n    bottom: \"headroom--bottom\",\n    notBottom: \"headroom--not-bottom\",\n    initial: \"headroom\"\n  }\n};\nHeadroom.cutsTheMustard = typeof features !== \"undefined\" && features.rAF && features.bind && features.classList;\nexport default Headroom;","map":{"version":3,"sources":["/home/mohammad/Desktop/hesabeh/src/common/navbar/Headroom.js"],"names":["features","Debouncer","isDOMElement","obj","window","nodeType","extend","object","arguments","length","Error","result","key","i","replacement","supportsCaptureOption","opts","Object","defineProperty","get","addEventListener","removeEventListener","e","addEventListenerWithOptions","target","type","handler","options","optionsOrCapture","capture","removeEventListenerWithOptions","normalizeTolerance","t","down","up","Headroom","elem","lastKnownScrollY","tolerance","classes","offset","scroller","initialised","onPin","onUnpin","onTop","onNotTop","onBottom","onNotBottom","frozen","prototype","constructor","init","cutsTheMustard","debouncer","update","bind","classList","add","initial","setTimeout","attachEvent","destroy","hasOwnProperty","call","remove","passive","getScrollY","handleEvent","unpin","contains","pinned","unpinned","pin","top","notTop","bottom","notBottom","pageYOffset","undefined","scrollTop","document","documentElement","body","parentNode","getViewportHeight","innerHeight","clientHeight","getElementPhysicalHeight","elm","Math","max","offsetHeight","getScrollerPhysicalHeight","getDocumentHeight","scrollHeight","getElementHeight","getScrollerHeight","isOutOfBounds","currentScrollY","pastTop","pastBottom","toleranceExceeded","direction","abs","shouldUnpin","scrollingDown","pastOffset","shouldPin","scrollingUp","scrollDirection","freeze","unfreeze","rAF"],"mappings":"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","sourcesContent":["import features from \"./features\";\nimport Debouncer from \"./Debouncer\";\n\n/**\n * Check if object is part of the DOM\n * @constructor\n * @param {Object} obj element to check\n */\nfunction isDOMElement(obj) {\n  return (\n    obj && typeof window !== \"undefined\" && (obj === window || obj.nodeType)\n  );\n}\n\n/**\n * Helper function for extending objects\n */\nfunction extend(object /*, objectN ... */) {\n  if (arguments.length <= 0) {\n    throw new Error(\"Missing arguments in extend function\");\n  }\n\n  var result = object || {},\n    key,\n    i;\n\n  for (i = 1; i < arguments.length; i++) {\n    var replacement = arguments[i] || {};\n\n    for (key in replacement) {\n      // Recurse into object except if the object is a DOM element\n      if (typeof result[key] === \"object\" && !isDOMElement(result[key])) {\n        result[key] = extend(result[key], replacement[key]);\n      } else {\n        result[key] = result[key] || replacement[key];\n      }\n    }\n  }\n\n  return result;\n}\n\n/**\n * Used to detect browser support for adding an event listener with options\n * Credit: https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\n */\nvar supportsCaptureOption = false;\ntry {\n  var opts = Object.defineProperty({}, \"capture\", {\n    get: function() {\n      return (supportsCaptureOption = true);\n    }\n  });\n  window.addEventListener(\"test\", null, opts);\n  window.removeEventListener(\"test\", null, opts);\n} catch (e) {\n  /* eslint-ignore-line */\n}\n\n/**\n * Helper to add an event listener with an options object in supported browsers\n */\nfunction addEventListenerWithOptions(target, type, handler, options) {\n  var optionsOrCapture = options;\n  if (!supportsCaptureOption) {\n    optionsOrCapture = options.capture;\n  }\n  target.addEventListener(type, handler, optionsOrCapture);\n}\n\n/**\n * Helper to remove an event listener with an options object in supported browsers\n */\nfunction removeEventListenerWithOptions(target, type, handler, options) {\n  var optionsOrCapture = options;\n  if (!supportsCaptureOption) {\n    optionsOrCapture = options.capture;\n  }\n  target.removeEventListener(type, handler, optionsOrCapture);\n}\n\n/**\n * Helper function for normalizing tolerance option to object format\n */\nfunction normalizeTolerance(t) {\n  return t === Object(t) ? t : { down: t, up: t };\n}\n\n/**\n * UI enhancement for fixed headers.\n * Hides header when scrolling down\n * Shows header when scrolling up\n * @constructor\n * @param {DOMElement} elem the header element\n * @param {Object} options options for the widget\n */\nfunction Headroom(elem, options) {\n  options = extend(options, Headroom.options);\n\n  this.lastKnownScrollY = 0;\n  this.elem = elem;\n  this.tolerance = normalizeTolerance(options.tolerance);\n  this.classes = options.classes;\n  this.offset = options.offset;\n  this.scroller = options.scroller;\n  this.initialised = false;\n  this.onPin = options.onPin;\n  this.onUnpin = options.onUnpin;\n  this.onTop = options.onTop;\n  this.onNotTop = options.onNotTop;\n  this.onBottom = options.onBottom;\n  this.onNotBottom = options.onNotBottom;\n  this.frozen = false;\n}\nHeadroom.prototype = {\n  constructor: Headroom,\n\n  /**\n   * Initialises the widget\n   */\n  init: function() {\n    if (!Headroom.cutsTheMustard) {\n      return;\n    }\n\n    this.debouncer = new Debouncer(this.update.bind(this));\n    this.elem.classList.add(this.classes.initial);\n\n    // defer event registration to handle browser\n    // potentially restoring previous scroll position\n    setTimeout(this.attachEvent.bind(this), 100);\n\n    return this;\n  },\n\n  /**\n   * Unattaches events and removes any classes that were added\n   */\n  destroy: function() {\n    var classes = this.classes;\n\n    this.initialised = false;\n\n    for (var key in classes) {\n      if (Object.prototype.hasOwnProperty.call(classes, key)) {\n        this.elem.classList.remove(classes[key]);\n      }\n    }\n\n    removeEventListenerWithOptions(this.scroller, \"scroll\", this.debouncer, {\n      capture: false,\n      passive: true\n    });\n  },\n\n  /**\n   * Attaches the scroll event\n   * @private\n   */\n  attachEvent: function() {\n    if (!this.initialised) {\n      this.lastKnownScrollY = this.getScrollY();\n      this.initialised = true;\n      addEventListenerWithOptions(this.scroller, \"scroll\", this.debouncer, {\n        capture: false,\n        passive: true\n      });\n\n      this.debouncer.handleEvent();\n    }\n  },\n\n  /**\n   * Unpins the header if it's currently pinned\n   */\n  unpin: function() {\n    var classList = this.elem.classList,\n      classes = this.classes;\n\n    if (\n      classList.contains(classes.pinned) ||\n      !classList.contains(classes.unpinned)\n    ) {\n      classList.add(classes.unpinned);\n      classList.remove(classes.pinned);\n      if (this.onUnpin) {\n        this.onUnpin.call(this);\n      }\n    }\n  },\n\n  /**\n   * Pins the header if it's currently unpinned\n   */\n  pin: function() {\n    var classList = this.elem.classList,\n      classes = this.classes;\n\n    if (classList.contains(classes.unpinned)) {\n      classList.remove(classes.unpinned);\n      classList.add(classes.pinned);\n      if (this.onPin) {\n        this.onPin.call(this);\n      }\n    }\n  },\n\n  /**\n   * Handles the top states\n   */\n  top: function() {\n    var classList = this.elem.classList,\n      classes = this.classes;\n\n    if (!classList.contains(classes.top)) {\n      classList.add(classes.top);\n      classList.remove(classes.notTop);\n      if (this.onTop) {\n        this.onTop.call(this);\n      }\n    }\n  },\n\n  /**\n   * Handles the not top state\n   */\n  notTop: function() {\n    var classList = this.elem.classList,\n      classes = this.classes;\n\n    if (!classList.contains(classes.notTop)) {\n      classList.add(classes.notTop);\n      classList.remove(classes.top);\n      if (this.onNotTop) {\n        this.onNotTop.call(this);\n      }\n    }\n  },\n\n  bottom: function() {\n    var classList = this.elem.classList,\n      classes = this.classes;\n\n    if (!classList.contains(classes.bottom)) {\n      classList.add(classes.bottom);\n      classList.remove(classes.notBottom);\n      if (this.onBottom) {\n        this.onBottom.call(this);\n      }\n    }\n  },\n\n  /**\n   * Handles the not top state\n   */\n  notBottom: function() {\n    var classList = this.elem.classList,\n      classes = this.classes;\n\n    if (!classList.contains(classes.notBottom)) {\n      classList.add(classes.notBottom);\n      classList.remove(classes.bottom);\n\n      if (this.onNotBottom) {\n        this.onNotBottom.call(this);\n      }\n    }\n  },\n\n  /**\n   * Gets the Y scroll position\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollY\n   * @return {Number} pixels the page has scrolled along the Y-axis\n   */\n  getScrollY: function() {\n    if (this.scroller.pageYOffset !== undefined) {\n      return this.scroller.pageYOffset;\n    }\n    if (this.scroller.scrollTop !== undefined) {\n      return this.scroller.scrollTop;\n    }\n    return (\n      document.documentElement ||\n      document.body.parentNode ||\n      document.body\n    ).scrollTop;\n  },\n\n  /**\n   * Gets the height of the viewport\n   * @see http://andylangton.co.uk/blog/development/get-viewport-size-width-and-height-javascript\n   * @return {int} the height of the viewport in pixels\n   */\n  getViewportHeight: function() {\n    return (\n      window.innerHeight ||\n      document.documentElement.clientHeight ||\n      document.body.clientHeight\n    );\n  },\n\n  /**\n   * Gets the physical height of the DOM element\n   * @param  {Object}  elm the element to calculate the physical height of which\n   * @return {int}     the physical height of the element in pixels\n   */\n  getElementPhysicalHeight: function(elm) {\n    return Math.max(elm.offsetHeight, elm.clientHeight);\n  },\n\n  /**\n   * Gets the physical height of the scroller element\n   * @return {int} the physical height of the scroller element in pixels\n   */\n  getScrollerPhysicalHeight: function() {\n    return this.scroller === window || this.scroller === document.body\n      ? this.getViewportHeight()\n      : this.getElementPhysicalHeight(this.scroller);\n  },\n\n  /**\n   * Gets the height of the document\n   * @see http://james.padolsey.com/javascript/get-document-height-cross-browser/\n   * @return {int} the height of the document in pixels\n   */\n  getDocumentHeight: function() {\n    var body = document.body,\n      documentElement = document.documentElement;\n\n    return Math.max(\n      body.scrollHeight,\n      documentElement.scrollHeight,\n      body.offsetHeight,\n      documentElement.offsetHeight,\n      body.clientHeight,\n      documentElement.clientHeight\n    );\n  },\n\n  /**\n   * Gets the height of the DOM element\n   * @param  {Object}  elm the element to calculate the height of which\n   * @return {int}     the height of the element in pixels\n   */\n  getElementHeight: function(elm) {\n    return Math.max(elm.scrollHeight, elm.offsetHeight, elm.clientHeight);\n  },\n\n  /**\n   * Gets the height of the scroller element\n   * @return {int} the height of the scroller element in pixels\n   */\n  getScrollerHeight: function() {\n    return this.scroller === window || this.scroller === document.body\n      ? this.getDocumentHeight()\n      : this.getElementHeight(this.scroller);\n  },\n\n  /**\n   * determines if the scroll position is outside of document boundaries\n   * @param  {int}  currentScrollY the current y scroll position\n   * @return {bool} true if out of bounds, false otherwise\n   */\n  isOutOfBounds: function(currentScrollY) {\n    var pastTop = currentScrollY < 0,\n      pastBottom =\n        currentScrollY + this.getScrollerPhysicalHeight() >\n        this.getScrollerHeight();\n\n    return pastTop || pastBottom;\n  },\n\n  /**\n   * determines if the tolerance has been exceeded\n   * @param  {int} currentScrollY the current scroll y position\n   * @return {bool} true if tolerance exceeded, false otherwise\n   */\n  toleranceExceeded: function(currentScrollY, direction) {\n    return (\n      Math.abs(currentScrollY - this.lastKnownScrollY) >=\n      this.tolerance[direction]\n    );\n  },\n\n  /**\n   * determine if it is appropriate to unpin\n   * @param  {int} currentScrollY the current y scroll position\n   * @param  {bool} toleranceExceeded has the tolerance been exceeded?\n   * @return {bool} true if should unpin, false otherwise\n   */\n  shouldUnpin: function(currentScrollY, toleranceExceeded) {\n    var scrollingDown = currentScrollY > this.lastKnownScrollY,\n      pastOffset = currentScrollY >= this.offset;\n\n    return scrollingDown && pastOffset && toleranceExceeded;\n  },\n\n  /**\n   * determine if it is appropriate to pin\n   * @param  {int} currentScrollY the current y scroll position\n   * @param  {bool} toleranceExceeded has the tolerance been exceeded?\n   * @return {bool} true if should pin, false otherwise\n   */\n  shouldPin: function(currentScrollY, toleranceExceeded) {\n    var scrollingUp = currentScrollY < this.lastKnownScrollY,\n      pastOffset = currentScrollY <= this.offset;\n\n    return (scrollingUp && toleranceExceeded) || pastOffset;\n  },\n\n  /**\n   * Handles updating the state of the widget\n   */\n  update: function() {\n    var currentScrollY = this.getScrollY(),\n      scrollDirection = currentScrollY > this.lastKnownScrollY ? \"down\" : \"up\",\n      toleranceExceeded = this.toleranceExceeded(\n        currentScrollY,\n        scrollDirection\n      );\n\n    if (this.isOutOfBounds(currentScrollY)) {\n      // Ignore bouncy scrolling in OSX\n      return;\n    }\n\n    if (this.frozen === true) {\n      this.lastKnownScrollY = currentScrollY;\n      return;\n    }\n\n    if (currentScrollY <= this.offset) {\n      this.top();\n    } else {\n      this.notTop();\n    }\n\n    if (currentScrollY + this.getViewportHeight() >= this.getScrollerHeight()) {\n      this.bottom();\n    } else {\n      this.notBottom();\n    }\n\n    if (this.shouldUnpin(currentScrollY, toleranceExceeded)) {\n      this.unpin();\n    } else if (this.shouldPin(currentScrollY, toleranceExceeded)) {\n      this.pin();\n    }\n\n    this.lastKnownScrollY = currentScrollY;\n  },\n\n  /**\n   * Freezes the current state of the widget\n   */\n  freeze: function() {\n    this.frozen = true;\n    this.elem.classList.add(this.classes.frozen);\n  },\n\n  /**\n   * Re-enables the default behaviour of the widget\n   */\n  unfreeze: function() {\n    this.frozen = false;\n    this.elem.classList.remove(this.classes.frozen);\n  }\n};\n/**\n * Default options\n * @type {Object}\n */\nHeadroom.options = {\n  tolerance: {\n    up: 0,\n    down: 0\n  },\n  offset: 0,\n  scroller: window,\n  classes: {\n    frozen: \"headroom--frozen\",\n    pinned: \"headroom--pinned\",\n    unpinned: \"headroom--unpinned\",\n    top: \"headroom--top\",\n    notTop: \"headroom--not-top\",\n    bottom: \"headroom--bottom\",\n    notBottom: \"headroom--not-bottom\",\n    initial: \"headroom\"\n  }\n};\nHeadroom.cutsTheMustard =\n  typeof features !== \"undefined\" &&\n  features.rAF &&\n  features.bind &&\n  features.classList;\n\nexport default Headroom;\n"]},"metadata":{},"sourceType":"module"}